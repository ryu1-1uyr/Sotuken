<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<section>
    <input id="button_W" type="button" value="W" style="padding-left: 64px;text-align: center"
           onclick="addList('W')"><br>
    <input id="button_A" type="button" value="A" onclick="addList('A')">
    <input id="button_S" type="button" value="S" onclick="addList('S')">
    <input id="button_D" type="button" value="D" onclick="addList('D')"><br>
    <input type="button" value="rotate 90 migi"
           onclick="switchTarget(selectRotation,90);switchTarget(drawRotatedImage)">
    <input type="button" value="rotate 90 hidari"
           onclick="switchTarget(selectRotation,-90);switchTarget(drawRotatedImage)"><br>
    <input type="button" value="move" onclick="eval(makeCode(commands));commands=[]"><br>
    <input type="button" value="target at shigeru " onclick="target='sigeru'"><input type="button"
                                                                                     value="target at kumasan"
                                                                                     onclick="target='kumasan'">
</section>

<canvas id="board" width="500" height="500" style="  background-color: #888;
  background-image: linear-gradient(45deg, #444 25%, transparent 25%,
  transparent 75%, #444 75%, #444), linear-gradient(45deg, #444 25%,
  transparent 25%, transparent 75%, #444 75%, #444);
  background-position: 0 0, 100px 100px;
  background-size: 200px 200px;"></canvas>

<script>
    let commands = []

    let target = 'sigeru'

    const addList = (value) => {
        commands.push(value)
        console.log(commands)
    }

    const makeCode = (commands) => {
        let stringCode = 'async function evalfunction () {'
        commands.map((command) => {
            switch (command) {
                case 'W':
                    stringCode += 'await sleep(400).then(() => {'
                    stringCode += `switchTarget(moveup);});`
                    break
                case 'A':
                    stringCode += 'await sleep(400).then(() => {'
                    stringCode += `switchTarget(moveleft);});`
                    break
                case 'S':
                    stringCode += 'await sleep(400).then(() => {'
                    stringCode += `switchTarget(movedown);});`
                    break
                case 'D':
                    stringCode += 'await sleep(400).then(() => {'
                    stringCode += `switchTarget(moveright);});`
                    break
                default:

            }
            //stringCode += 'if (x == p2.x) {console.log(\'いたーい\')};'//ダメージなどの処理
        })
        stringCode += '};'
        return stringCode + 'evalfunction()'
    }

    function sleep(waitSec) {
        return new Promise(function (resolve) {
            setTimeout(function () {
                resolve()
            }, waitSec);
        });
    }

    const canvas = document.getElementById('board');

    const ctx = canvas.getContext("2d");
    const ctx2 = canvas.getContext("2d");


    let movement = 100

    const sigeru = new Image();
    sigeru.src = 'sigeru.png'

    let fukuoka = new Image();
    fukuoka.src = "asdsd.gif";

    const p1 = {
        name: 'sigeru',
        x: 0,
        y: 400,
        image: sigeru,
        direction: 0,
    }

    const p2 = {
        name: 'kumasan',
        x: 400,
        y: 0,
        image: fukuoka,
        direction: 0,
    }

    //drawRotatedImage(p2.image,p2.x,p2.y,90)

    const selectRotation = target => radius => {
        target.direction += radius
    }

    const TO_RADIANS = Math.PI / 180;
    /**
     * 回転させた画像を表示する
     * @param {object} image - Imageオブジェクト
     * @param {number} x - 画像の中心となるX座標
     * @param {number} y - 画像の中心となるY座標
     * @param {number} angle - 回転する角度[度]
     */
    const drawRotatedImage = (target, target2) => {

        ctx.clearRect(0, 0, canvas.width, canvas.height)

        // コンテキストを保存する
        ctx.save();
        // 回転の中心に原点を移動する
        ctx.translate(target.x + 100, target.y);
        // ctx.translate(target2.x , target2.y);

        // canvasを回転する
        ctx.rotate((target.direction) * TO_RADIANS);

        console.log(target.direction)
        console.log((
            Math.floor(target.direction / 90) >= 4 && Math.floor(target.direction / 90) >= 0 ?
                Math.floor(target.direction / 90) - 4 :
                Math.floor(target.direction / 90) < 0
                    ? 360 + Math.floor(target.direction)
                    : Math.floor(target.direction / 90)
        ))

        if (target.direction < 0) {
            target.direction = Math.floor(target.direction / 90) >= 4 && Math.floor(target.direction / 90) >= 0 ?
                Math.floor(target.direction / 90) - 4 :
                Math.floor(target.direction / 90) < 0
                    ? 360 + Math.floor(target.direction)
                    : Math.floor(target.direction / 90)
        } else if (target.direction >= 360){
            target.direction = 0
        }

        // console.log(Math.floor(target.direction / 90) >= 4 ? Math.floor(target.direction / 90) -4: Math.floor(target.direction / 90) )
        switch (
            Math.floor(target.direction / 90) >= 4 && Math.floor(target.direction / 90) >= 0 ?
                Math.floor(target.direction / 90) - 4 :
                Math.floor(target.direction / 90) < 0 ?
                    360 + Math.floor(target.direction) :
                    Math.floor(target.direction / 90)
            ) {
            case 1://90
                ctx.drawImage(target.image, -(0), -(0), 100, 100);
                // ctx.drawImage(target2.image, -(0), -(0), 100, 100);
                break
            case 2://180
                ctx.drawImage(target.image, -(0), -(100), 100, 100);
                // ctx.drawImage(target2.image, -(0), -(100), 100, 100);
                break
            case 3://270
                ctx.drawImage(target.image, -(100), -(100), 100, 100);
                // ctx.drawImage(target2.image, -(100), -(100), 100, 100);
                break
            case 0://0
                ctx.drawImage(target.image, -(100), -(0), 100, 100);
                // ctx.drawImage(target2.image, -(100), -(0), 100, 100);
                break
            default:

        }
        // コンテキストを元に戻す
        ctx.restore();
console.log(target2.direction,'2p')
        if (target2.direction === 0){
            ctx.drawImage(target2.image, target2.x, target2.y, 100, 100);
        } else {
            // コンテキストを保存する
            ctx.save();
            // 回転の中心に原点を移動する
            ctx.translate(target2.x + 100, target2.y);

            // canvasを回転する
            ctx.rotate((target2.direction) * TO_RADIANS);

            switch (
                Math.floor(target2.direction / 90) >= 4 && Math.floor(target2.direction / 90) >= 0 ?
                    Math.floor(target2.direction / 90) - 4 :
                    Math.floor(target2.direction / 90) < 0 ?
                        360 + Math.floor(target2.direction) :
                        Math.floor(target2.direction / 90)
                ) {
                case 1://90
                    ctx.drawImage(target2.image, -(0), -(0), 100, 100);
                    // ctx.drawImage(target2.image, -(0), -(0), 100, 100);
                    break
                case 2://180
                    ctx.drawImage(target2.image, -(0), -(100), 100, 100);
                    // ctx.drawImage(target2.image, -(0), -(100), 100, 100);
                    break
                case 3://270
                    ctx.drawImage(target2.image, -(100), -(100), 100, 100);
                    // ctx.drawImage(target2.image, -(100), -(100), 100, 100);
                    break
                case 0://0
                    ctx.drawImage(target2.image, -(100), -(0), 100, 100);
                    // ctx.drawImage(target2.image, -(100), -(0), 100, 100);
                    break
                default:

            }
        }
        ctx.restore();


    }

    let x = 0
    let y = 400;

    let x_2 = 400
    let y_2 = 0;


    // ctx.fillStyle = "rgb(200,0,0)";
    ctx.drawImage(p1.image, 0, 0, 100, 100, p1.x, p1.y, 100, 100);

    // ctx2.fillStyle = "rgb(200,0,200)";


    ctx.drawImage(p2.image, p2.x, p2.y, 100, 100);

    //

    function moveright(target, target2) {
        console.log('right')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        if (target.x == target2.x - 100 && target.y == target2.y) {
            console.log('いたーい')
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)
        } else if (target.x <= 300) {
            target.x += movement
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)


        } else {
            console.log('out of range ', target.x)
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)
        }
        ctx.fillStyle = "rgb(0,0,200)";
        // drawRotatedImage(target2,target)

    }

    function moveleft(target, target2) {

        console.log('left')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        if (target.x == target2.x + 100 && target.y == target2.y) {
            console.log('いたーい')
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)

        } else if (target.x > 0) {
            target.x -= movement
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)

        } else {
            ctx.fillStyle = "rgb(200,0,0)";
            ctx.drawImage(target.image, target.x, target.y, 100, 100);
            // y += movement
        }
        ctx.fillStyle = "rgb(0,0,200)";
        // drawRotatedImage(target2,target)

    }

    function moveup(target, target2) {
        console.log('up')
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        if (target.x == target2.x && target.y == target2.y + 100) {
            console.log('いたーい')
            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)
        } else if (target.y > 0) {
            ctx.fillStyle = "rgb(200,0,0)";
            target.y -= movement
            drawRotatedImage(target,target2)


        } else {
            console.log('out of range ', target.y)

            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)
        }
        ctx.fillStyle = "rgb(0,0,200)";
        // drawRotatedImage(target2,target)

    }

    function movedown(target, target2) {
        console.log('down')

        ctx.clearRect(0, 0, canvas.width, canvas.height)
        if (target.x == target2.x && target.y == target2.y - 100) {
            console.log('いたーい')
            ctx.fillStyle = "rgb(200,0,0)";
            ctx.drawImage(target.image, target.x, target.y, 100, 100);
        } else if (target.y < 400) {

            ctx.fillStyle = "rgb(200,0,0)";
            target.y += movement

            drawRotatedImage(target,target2)

        } else {
            console.log('out of range', target.y)

            ctx.fillStyle = "rgb(200,0,0)";
            drawRotatedImage(target,target2)
        }
        ctx.fillStyle = "rgb(0,0,200)";
        // drawRotatedImage(target2,target)

    }

    // async function start() {
    //     await sleep(2000);
    //     console.log('2秒経過しました');
    //     draw()
    //
    //     // await sleep(1000);
    //     // console.log('1秒経過しました');
    //     //
    //     // await sleep(3000);
    //     // console.log('3秒経過しました');
    // }

    // .then(() => {
    //     sleep(1000).then(() => {
    //         console.log('i')
    //         draw()
    //         //2つ目の命令
    //     })
    // })

    async function 非同期処理存在() {

        await sleep(500).then(() => {
            moveright()
        })

        await sleep(500).then(() => {
            moveright()
        })

        await sleep(500).then(() => {
            moveright()
        })

        await sleep(500).then(() => {
            moveleft()
        })

    }

    // 非同期処理存在();

    // async function 非同期まとめ上げ存在() {
    //     await 非同期処理存在()
    //     await 非同期処理存在()
    //     await 非同期処理存在()
    //     await 非同期処理存在()
    // }
    //
    // async function 非同期顧問存在() {
    //     await 非同期まとめ上げ存在()
    //     await 非同期まとめ上げ存在()
    //     await 非同期まとめ上げ存在()
    //     await 非同期まとめ上げ存在()
    // }
    //
    // async function 非同期PTA存在() {
    //     await 非同期顧問存在()
    //     await 非同期顧問存在()
    //     await 非同期顧問存在()
    //     await 非同期顧問存在()
    // }
    //
    // async function 非同期教育委員会存在() {
    //     await 非同期PTA存在()
    //     await 非同期PTA存在()
    //     await 非同期PTA存在()
    //     await 非同期PTA存在()
    // }
    //
    // 非同期教育委員会存在()

    // for (let o = 0 ; o < 4 ; o++ ){
    //     非同期まとめ上げ存在()
    // }


    // setInterval(sleep1 , 10)

    // if (target == 'sigeru'){
    //     moveup(p1,p2)
    // } else if (target == 'kumasan') {
    //     moveup(p2,p1)
    // }
    const switchTarget = (func, sub = null) => {
        if (target == p1.name) {
            if (sub) {
                func(p1, p2)(sub)
            } else {
                func(p1, p2)
            }
        } else if (target == p2.name) {
            if (sub) {
                func(p2, p1)(sub)
            } else {
                func(p2, p1)
            }
        }
    }

    window.addEventListener('keydown', event => {
        switch (event.key) {
            case 'w':
                switchTarget(moveup)
                break
            case 'a':
                switchTarget(moveleft)
                break
            case 's':
                switchTarget(movedown)
                break
            case 'd':
                switchTarget(moveright)
                break
            default :
                console.log(event)
        }

    })

</script>

</body>
</html>